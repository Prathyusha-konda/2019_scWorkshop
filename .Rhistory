# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 0.6,
print.output = 0,
save.SNN = TRUE)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
# find all markers of cluster 1
cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 1, min.pct = 0.25)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 0.6,
print.output = 0,
save.SNN = TRUE)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 1,
print.output = 0,
save.SNN = TRUE)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 1,
print.output = 0)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
# find all markers of cluster 1
cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 1, min.pct = 0.25)
print(x = head(x = cluster1.markers, n = 5))
# find all markers distinguishing cluster 5 from clusters 0 and 3
cluster5.markers <- FindMarkers(object = pbmc, ident.1 = 5, ident.2 = c(0, 3),
min.pct = 0.25)
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
library(dplyr)
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
## Warning in BuildSNN(object = object, genes.use = genes.use, reduction.type
## = reduction.type, : Build parameters exactly match those of already
## computed and stored SNN. To force recalculation, set force.recalc to TRUE.
# Demonstration of how to plot two tSNE plots side by side, and how to color
# points based on different criteria
plot1 <- TSNEPlot(object = pbmc, do.return = TRUE, no.legend = TRUE, do.label = TRUE)
plot2 <- TSNEPlot(object = pbmc, do.return = TRUE, group.by = "ClusterNames_0.6",
no.legend = TRUE, do.label = TRUE)
# First lets stash our identities for later
pbmc <- StashIdent(object = pbmc, save.name = "ClusterNames_0.6")
# Note that if you set save.snn=T above, you don't need to recalculate the
# SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10,
resolution = 0.8, print.output = FALSE)
top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(10, avg_logFC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of
# every cell name
DoHeatmap(object = pbmc, genes.use = top10$gene, slim.col.label = TRUE, remove.key = TRUE)
?pbmc+pbmc_small
?pbmc_small
VariableGenePlot(object = pbmc,
do.text = TRUE,
cex.use = 0.5,
cex.text.use = 0.5,
do.spike = FALSE,
pch.use = 16,
col.use = "black",
spike.col.use = "red",
plot.both = FALSE,
do.contour = TRUE,
contour.lwd = 3,
contour.col = "white",
contour.lty = 2,
x.low.cutoff = 0.1,
x.high.cutoff = 8,
y.cutoff = 1,
y.high.cutoff = Inf)
set.seed(2019)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 1,
print.output = 0)
set.seed(2019)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
library(CountClust)
library(Seurat)
# deng.counts <- exprs(Deng2014MouseESC)
# deng.meta_data <- pData(Deng2014MouseESC)
# deng.gene_names <- rownames(deng.counts)
pbmc_counts <- as.matrix(pbmc_small@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- pbmc_FitGoM$fit$omega
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
## Add Topic Scores to Meta Data Part of the Seurat Object
pbmc_small@meta.data <- cbind(pbmc_meta, omega)
# deng.counts <- exprs(Deng2014MouseESC)
# deng.meta_data <- pData(Deng2014MouseESC)
# deng.gene_names <- rownames(deng.counts)
pbmc_counts <- as.matrix(pbmc_small@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- pbmc_FitGoM$fit$omega
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
## Add Topic Scores to Meta Data Part of the Seurat Object
pbmc_small@meta.data <- cbind(pbmc_meta, omega)
## ggplot object, you can add layers
p1 <- TSNEPlot(pbmc_small, do.return = TRUE) + labs(title = "Resolution 1") ## return ggplot object
p1
p2 <- FeaturePlot(object = pbmc_small,
features.plot = c("topic1", "topic2", "topic3", "topic4"),
cols.use = c("grey", "blue"),
reduction.use = "tsne", do.return = TRUE) ## return ggplot object
p2
plot_grid(p1, p2)
class(p2)
plot_grid(p1, p2[[1]], p2[[2]], p2[[3]], p2[[4]])
?RunICA
pbmc <- RunICA(object = pbmc,
pc.genes = pbmc@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
pbmc <- RunICA(object = pbmc,
ic.genes = pbmc@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
pbmc <- RunICA(object = pbmc,
ic.genes = pbmc@var.genes,
do.print = TRUE,
ics.print = 1:5,
genes.print = 5)
pbmc <- RunICA(object = pbmc,
ic.genes = pbmc@var.genes,
ics.print = 1:5,
genes.print = 5)
pbmc_small <- RunICA(pbmc_small, ics.compute=5)
?RunPCA
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2)
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2)
pbmc@ident
pbmc@ident <- NULL
pbmc@ident <- ''
pbmc@ident <- factor()
pbmc@meta.data
pbmc@meta.data <- data.frame()
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
pbmc@meta.data <- data.frame()
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
pbmc@meta.data <- data.frame()
library(CountClust)
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
pbmc <- pbmc_small
pbmc@meta.data
pbmc@meta.data[,1:2]
View(pbmc_small@meta.data)
pbmc <- pbmc_small
pbmc@ident <- factor()
SetIdent(pbmc_small, "res.1")
SetIdent(pbmc_small, res.1)
?SetIdent
SetIdent(pbmc_small, cells.use = res.1, ident.use = 'res.1')
SetIdent(pbmc_small, ident.use = 'res.1')
pbmc_small@ident
# Find discriminating markers
tcell.markers <- FindMarkers(object = pbmc, ident.1 = 0, ident.2 = 1)
## Set Cluster Identity to the clustering using a resolution of 1 (res.1)
SetIdent(pbmc_small, ident.use = 'res.1')
pbmc_counts <- as.matrix(pbmc_small@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- pbmc_FitGoM$fit$omega
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
## Add Topic Scores to Meta Data Part of the Seurat Object
pbmc_small@meta.data <- cbind(pbmc_meta, omega)
set.seed(2019)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
rm(list=ls())
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
library(CountClust)
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
library(CountClust)
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI"), nCol = 2)#, "percent.mito"), nCol = 3)
pbmc@meta.data
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI"), nCol = 2)#, "percent.mito"), nCol = 3)
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
##VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI"), "percent.mito"), nCol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "nGene")
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
# pbmc@ident <- factor()
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
##VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI"), "percent.mito"), nCol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "nGene")
?SetIdent
SetIdent(pbmc, ident.use = NULL)
SetIdent(pbmc, ident.use = '')
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
##VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI"), "percent.mito"), nCol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "nGene")
pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc <- FindVariableGenes(object = pbmc,
mean.function = ExpMean,
dispersion.function = LogVMR,
x.low.cutoff = 0.0125,
x.high.cutoff = 3,
y.cutoff = 0.5)
?FindVariableGenes
pbmc <- FindVariableGenes(object = pbmc,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE
x.low.cutoff = 0.0125,
pbmc <- FindVariableGenes(object = pbmc,
mean.function = ExpMean,
dispersion.function = LogVMR,
do.plot = FALSE)
pbmc <- ScaleData(object = pbmc, vars.to.regress = c("nUMI", "percent.mito"))
pbmc <- RunPCA(object = pbmc,
pc.genes = pbmc@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
>VizICA()
theta_mat <- pbmc_FitGoM$theta;
top_features <- ExtractTopFeatures(theta_mat, top_features=100,
method="poisson", options="min");
gene_list <- do.call(rbind, lapply(1:dim(top_features$indices)[1],
function(x) deng.gene_names[top_features$indices[x,]]))
top_features <- ExtractTopFeatures(theta_mat, top_features=100,
method="poisson", options="min")
pbmc_FitGoM$theta
## Set Cluster Identity to the clustering using a resolution of 1 (res.1)
SetIdent(pbmc_small, ident.use = 'res.1')
pbmc_counts <- as.matrix(pbmc_small@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- pbmc_FitGoM$fit$omega
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
## Add Topic Scores to Meta Data Part of the Seurat Object
pbmc_small@meta.data <- cbind(pbmc_meta, omega)
theta_mat <- pbmc_FitGoM$theta
top_features <- ExtractTopFeatures(theta_mat,
top_features=100,
method="poisson",
options="min")
theta_mat <- pbmc_FitGoM$fit$theta
top_features <- ExtractTopFeatures(theta_mat,
top_features=100,
method="poisson",
options="min")
gene_list <- do.call(rbind, lapply(1:dim(top_features$indices)[1],
function(x) deng.gene_names[top_features$indices[x,]]))
pbmc_small@meta.data
pbmc_small@meta.data %>% group_by(res.1) %>% summarise(mean(topic1))
pbmc_small@meta.data[,1:10] %>% group_by(res.1) %>% summarise(mean(topic1))
pbmc_small@meta.data[,1:10] %>%
group_by(res.1) %>%
summarise(topic1 = mean(topic1),
topic2 = mean(topic2),
topic3 = mean(topic3),
topic4 = mean(topic4))
?RunUMAP
?ClassifyCells
test.pbmc <- SubsetData(object = pbmc_small, cells.use = pbmc_small@cell.names[1:10])
train.pbmc <- SubsetData(object = pbmc_small, cells.use = pbmc_small@cell.names[11:80])
predicted.classes <- ClassifyCells(
object = train.pbmc,
training.classes = train.pbmc@ident,
new.data = test.pbmc@data
)
predicted.classes$
?
predicted.classes
test.pbmc@ident
?GetCentroids
pmbc_small <- GetCentroids(pbmc_small, cells.use=pbmc_small@cell.names)
PCHeatmap(object = pbmc,
pc.use = 1,
cells.use = 50,
do.balanced = TRUE,
label.columns = FALSE)
