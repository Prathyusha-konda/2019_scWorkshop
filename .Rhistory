bookdown::render_book(".")
bookdown::render_book(".")
devtools::install_github("compbiomed/celda@v0.6")
devtools::install_github("compbio/celda")
devtools::install_github("compbiomed/celda")
bookdown::render_book(".")
bookdown::render_book(".")
?knitr::write_bib
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
library(Rsamtools)
bookdown::render_book(".")
bookdown::render_book(".")
#The R function bw.liao implements the two bandwidths, h2 and h3, in
#Liao, J.G., Wu, Y.J. and Lin, Y. (2010)  Improving Sheather and Jones
#  bandwidth selector for difficult densities in kernel density estimation.
#  Journal of Nonparametric Statistics 22, 105-114.
# The h2 and h3 are very close. If you have to choose, we suggest you use h2 for sample size <= 400
# and use h3 for sample size larger.
#An example in the bottom of this file
##
V.deriv.func = function(h, s, q, w, mu, sigma2, equal.w = FALSE)
{
#sigma.local = sqrt( outer(sigma2, sigma2, "+") + q*h*h )    #general form for sigma2  that can differ from element to element
sigma.local = sqrt( sigma2[1] + sigma2[1] + q*h*h ) # applies when all elements of sigma2 are the same
diff1 = outer(mu, mu, "-")/sigma.local
term1 = K.deriv(diff1, 2*s)/(sigma.local^(2*s+1))
term2 = K.deriv(diff1, 2*s+2)/(sigma.local^(2*s+3))
if(equal.w == TRUE)
{
term1 = 2*s*h^(2*s-1)*sum(term1)
term2 = q*h^(2*s+1)*sum(term2)
(term1+term2)/length(w)^2
}
else
{
term1+term2
ww = outer(w, w, "*")
term1 = 2*s*h^(2*s-1)*sum(term1*ww)
term2 = q*h^(2*s+1)*sum(term2*ww)
term1+term2
}
}
MISE.deriv.cal.exact = function(h, n, w, mu, sigma2, equal.w = FALSE)
{
term1 = -1/(2*sqrt(pi))/(n*h*h)
term2 = (1-1/n)*V.deriv.func(h, 0, 2, w, mu, sigma2, equal.w)
term3 = -2*V.deriv.func(h, 0, 1, w, mu, sigma2, equal.w)
term1 + term2 + term3
}
####################################
H = function(u, k)
{
if(k>=2) u2 = u*u
if(k>=4) u4 = u2*u2
if(k>=6) u6 = u2*u4
if(k>=8) u8 = u4*u4
if(k>=10) u10 = u8*u2
if(k==0) 1
else if(k==1) u
else if(k==2) u2 - 1
else if(k==4) u4 - 6*u2 + 3
else if(k==6) u6 - 15*u4 + 45*u2 - 15
else if(k==8) u8 - 28*u6 + 210*u4 - 420*u2 + 105
else if(k==10) u10 - 45*u8 + 630*u6 - 3150*u4 + 4725*u2 - 945
}
K.deriv = function(u, k) H(u, k)*dnorm(u)
Phi = function(x, h1, k)
{
n = length(x)
x = x/h1
temp = outer(x, x, "-")
n/(n-1)*mean(K.deriv(temp, k))/h1^(k+1)
}
g4.initial = function(x)     #g4 as obtained from SJ bandwidth, h0 is bw.SJ
{
n = length(x)
nb = 4000 #number of bins
Z <- .Call(stats:::C_bw_den, nb, x)
d <- Z[[1L]]      #needed for the faster functions
cnt <- as.integer(Z[[2L]])  #this will be a r
scale <- min(sd(x), IQR(x)/1.349)
a = 1.24 * scale * n^(-1/7)
b = 1.23 * scale * n^(-1/9)
alph2 = 1.357 * (SDh(cnt, a, n, d)/-TDh(cnt, b, n, d))^(1/7)
alph2 * (bw.SJ(x))^(5/7) #output g4 as used in bw.SJ
}
#####################################################################
bw.liao.exact = function(x)
{
n = length(x)
RK = 1/2/sqrt(pi)
temp = 2*K.deriv(0, 4)/RK
h1 = NULL
func1 = function(log.g4)   #g4 is the bandwidth to estimate R2 from sample x_1,...,x_n
{
g4 = exp(log.g4)
g6 = .992*g4*n^(1/7-1/9)
ratio = -Phi(x, g6, 4)/Phi(x, g6, 6)
theFactor = (temp*ratio)^(1/7)      #reference distribution with R2
h1 <<- (g4/theFactor)^(7/5)
w = rep(1/n, n)
sigma2 = rep(g4*g4/2, length(w))  #g4/sqrt(2) is the bandwidth, for using Wand and Marron's exact formula in Theorem 5.1
MISE.deriv.cal.exact(h1, n, w, x, sigma2, equal.w=TRUE)
}
g4 = g4.initial(x)
interval = log(c(g4/10, g4*10))
value1 = func1(interval[1])
value2 = func1(interval[2])
if(value1*value2 > 0) bw.SJ(x)
else
{
uniroot(func1, interval, f.lower=value1, f.upper=value2)
h1
}
}
#### the above is exact solution and below is approximate solution   #########
SDh <- function(x, h, n, d) .Call(stats:::C_bw_phi4, n, d, as.double(x), h)   #Phi4  x will be replaced by a processed version cnt
TDh <- function(x, h, n, d) .Call(stats:::C_bw_phi6, n, d, as.double(x), h)    #Phi6  x will be replaced by a processed version cnt
#### the above is exact solution and below is approximate solution   #########
MISE.deriv.cal.approx = function(h1, n, I2, I3, RK)   #this is a simplified form as in Hall (1991)
{
h2 = (RK/I2/n)^.2
ratio2 = I2/I3
J2 = 3/20/ratio2
h1 - (h2 + J2*h2^3)
}
bw.liao.approx = function (x, nb = 4000, SJ=F) #nb is the number of bins
{
n = length(x)
Z <- .Call(stats:::C_bw_den, nb, x)
d <- Z[[1L]]      #needed for the faster functions
cnt <- as.integer(Z[[2L]])  #this will be a replacement for x in  SDh and TDh
RK = 1/2/sqrt(pi)
temp = 2*K.deriv(0, 4)/RK
h1 = NULL
func1 = function(log.g4)
{
g4 = exp(log.g4)
g6 = .992*g4*n^(1/7-1/9)
ratio = -SDh(cnt, g6, n, d)/TDh(cnt, g6, n, d)
theFactor = (temp*ratio)^(1/7)
h1 <<- (g4/theFactor)^(7/5)
I2 = SDh(cnt, g4, n, d)
I3 = -TDh(cnt, g4, n, d)
MISE.deriv.cal.approx(h1, n, I2, I3, RK)
}
g4 = g4.initial(x)
interval = log(c(g4/10, g4*10))
value1 = func1(interval[1])
value2 = func1(interval[2])
if(value1*value2 > 0) bw.SJ(x)
else
{
uniroot(func1, interval, f.lower=value1, f.upper=value2)
h1
}
}
###########################################################################3
bw.liao = function(x)
{
n.exact = 400
if(length(x) <= n.exact) h2.value = bw.liao.exact(x)
else h2.value = bw.liao.approx(x)     # bw.liao.approx2(x, n.exact)
list(h2=h2.value, h3=min(h2.value, bw.SJ(x)))
}
#################################################
###### Example ####################
x = c(rnorm(400), rnorm(400)+3)
bw = bw.liao(x)
plot(density(x, bw=bw$h3))
plot(density(x))
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
bookdown::render_book(".")
paste("Hello", "World", sep= " ")
paste("Hello", "World", sep= "\t")
paste("Hello", "World", sep= "\n")
cat("Hello", "World", sep= " ")
cat("Hello", "World", sep= "\t")
cat("Hello", "World", sep= "\n")
library(Seurat)
Read10X("~/Documents/data/outs/filtered_gene_bc_matrices/hg19")
rawdata <- Read10X("~/Documents/data/outs/filtered_gene_bc_matrices/hg19")
obj <- CreateSeuratObject(raw.data = rawdata)
obj@raw.data
obj@raw.data[,1]
plot(obj@raw.data[,1])
plot(density(obj@raw.data[,1]))
source('~/Downloads/bw.liao')
source('~/Downloads/bw.liao.R')
source('~/Downloads/bw_liao.R')
bw <- bw.liao(obj@raw.data[,1])
plot(density(obj@raw.data[,1]))
max(obj@raw.data[,1])
min(obj@raw.data[,1])
objpbmc <- FilterCells(object = pbmc, subset.names = c("nGene", "percent.mito"),
low.thresholds = c(200, -Inf), high.thresholds = c(2500, 0.05))
pbmc <- obj
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
pbmc <- FilterCells(object = pbmc, subset.names = c("nGene", "percent.mito"),
low.thresholds = c(200, -Inf), high.thresholds = c(2500, 0.05))
pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize",
scale.factor = 10000)
pbmc <- FindVariableGenes(object = pbmc, mean.function = ExpMean, dispersion.function = LogVMR,
x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5)
pbmc <- ScaleData(object = pbmc, vars.to.regress = c("nUMI", "percent.mito"))
pbmc <- RunPCA(object = pbmc, pc.genes = pbmc@var.genes, do.print = TRUE, pcs.print = 1:5,
genes.print = 5)
pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10,
resolution = 0.6, print.output = 0, save.SNN = TRUE)
current.cluster.ids <- c(0, 1, 2, 3, 4, 5, 6, 7)
new.cluster.ids <- c("CD4 T cells", "CD14+ Monocytes", "B cells", "CD8 T cells",
"FCGR3A+ Monocytes", "NK cells", "Dendritic cells", "Megakaryocytes")
pbmc@ident <- plyr::mapvalues(x = pbmc@ident, from = current.cluster.ids, to = new.cluster.ids)
pbmc
rm(obj)
pbmc
?FilterCells()
pbmc@meta.data
rm(list=ls())
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
4^10
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
bookdown::render_book('.')
