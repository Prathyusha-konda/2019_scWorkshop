# We filter out cells that have unique gene counts over 2,500 or less than
# 200 Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
# threshold.
pbmc <- FilterCells(object = pbmc, subset.names = c("nGene", "percent.mito"),
low.thresholds = c(200, -Inf), high.thresholds = c(2500, 0.1))
# We filter out cells that have unique gene counts over 2,500 or less than
# 200 Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper
# threshold.
pbmc <- FilterCells(object = pbmc,
subset.names = c("nGene", "percent.mito"),
low.thresholds = c(200, -Inf),
high.thresholds = c(2500, 0.1))
pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc <- FindVariableGenes(object = pbmc,
mean.function = ExpMean,
dispersion.function = LogVMR,
x.low.cutoff = 0.0125,
x.high.cutoff = 3,
y.cutoff = 0.5)
pbmc <- ScaleData(object = pbmc, vars.to.regress = c("nUMI", "percent.mito"))
?ScaleData
pbmc <- RunPCA(object = pbmc,
pc.genes = pbmc@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
# Examine and visualize PCA results a few different ways
PrintPCA(object = pbmc,
pcs.print = 1:5,
genes.print = 5,
use.full = FALSE)
VizPCA(object = pbmc, pcs.use = 1:2)
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2)
?PCAPlot
# ProjectPCA scores each gene in the dataset (including genes not included
# in the PCA) based on their correlation with the calculated components.
# Though we don't use this further here, it can be used to identify markers
# that are strongly correlated with cellular heterogeneity, but may not have
# passed through variable gene selection.  The results of the projected PCA
# can be explored by setting use.full=T in the functions above
pbmc <- ProjectPCA(object = pbmc, do.print = FALSE)
PCHeatmap(object = pbmc, pc.use = 1, cells.use = 500, do.balanced = TRUE, label.columns = FALSE)
PCHeatmap(object = pbmc,
pc.use = 1,
cells.use = 50,
do.balanced = TRUE,
label.columns = FALSE)
PCHeatmap(object = pbmc,
pc.use = 1:12,
cells.use = 50,
do.balanced = TRUE,
label.columns = FALSE,
use.full = FALSE)
# NOTE: This process can take a long time for big datasets, comment out for
# expediency.  More approximate techniques such as those implemented in
# PCElbowPlot() can be used to reduce computation time
pbmc <- JackStraw(object = pbmc, num.replicate = 100, display.progress = FALSE)
JackStrawPlot(object = pbmc, PCs = 1:12)
PCElbowPlot(object = pbmc)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 0.6,
print.output = 0,
save.SNN = TRUE)
pbmc <- RunTSNE(object = pbmc, dims.use = 1:10, do.fast = TRUE)
?RunTSNE
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
## ggplot object, you can add layers
TSNEPlot(pbmc_small) + labs(title = "Resolution 1")
FeaturePlot(object = pbmc_small,
features.plot = c("topic1", "topic2", "topic3", "topic4", "res.1"),
cols.use = c("grey", "blue"),
reduction.use = "tsne")
library(CountClust)
library(Seurat)
# deng.counts <- exprs(Deng2014MouseESC)
# deng.meta_data <- pData(Deng2014MouseESC)
# deng.gene_names <- rownames(deng.counts)
pbmc_counts <- as.matrix(pbmc_small@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- pbmc_FitGoM$fit$omega
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
## Add Topic Scores to Meta Data Part of the Seurat Object
pbmc_small@meta.data <- cbind(pbmc_meta, omega)
## ggplot object, you can add layers
TSNEPlot(pbmc_small) + labs(title = "Resolution 1")
FeaturePlot(object = pbmc_small,
features.plot = c("topic1", "topic2", "topic3", "topic4", "res.1"),
cols.use = c("grey", "blue"),
reduction.use = "tsne")
FeaturePlot(object = pbmc_small,
features.plot = c("topic1", "topic2", "topic3", "topic4"),
cols.use = c("grey", "blue"),
reduction.use = "tsne")
## ggplot object, you can add layers
TSNEPlot(pbmc_small) + labs(title = "Resolution 1 Louvain Clustering")
## ggplot object, you can add layers
p1 <- TSNEPlot(pbmc_small) + labs(title = "Resolution 1", do.return = TRUE) ## return ggplot object
p1
p2 <- FeaturePlot(object = pbmc_small,
features.plot = c("topic1", "topic2", "topic3", "topic4"),
cols.use = c("grey", "blue"),
reduction.use = "tsne", do.return = TRUE) ## return ggplot object
p2
plot_grid(p1, p2[[1]], p2[[2]], p2[[3]], p2[[4]])
rm(list=ls())
library(Seurat)
pbmc <- pbmc_small
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
# GenePlot is typically used to visualize gene-gene relationships, but can
# be used for anything calculated by the object, i.e. columns in
# object@meta.data, PC scores etc.  Since there is a rare subset of cells
# with an outlier level of high mitochondrial percentage and also low UMI
# content, we filter these as well
par(mfrow = c(1, 2))
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "nGene")
pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc <- FindVariableGenes(object = pbmc,
mean.function = ExpMean,
dispersion.function = LogVMR,
x.low.cutoff = 0.0125,
x.high.cutoff = 3,
y.cutoff = 0.5)
pbmc <- ScaleData(object = pbmc, vars.to.regress = c("nUMI", "percent.mito"))
pbmc <- RunPCA(object = pbmc,
pc.genes = pbmc@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
# Examine and visualize PCA results a few different ways
PrintPCA(object = pbmc,
pcs.print = 1:5,
genes.print = 5,
use.full = FALSE)
VizPCA(object = pbmc, pcs.use = 1:2)
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2)
# ProjectPCA scores each gene in the dataset (including genes not included
# in the PCA) based on their correlation with the calculated components.
# Though we don't use this further here, it can be used to identify markers
# that are strongly correlated with cellular heterogeneity, but may not have
# passed through variable gene selection.  The results of the projected PCA
# can be explored by setting use.full=T in the functions above
pbmc <- ProjectPCA(object = pbmc, do.print = FALSE)
PCHeatmap(object = pbmc,
pc.use = 1,
cells.use = 50,
do.balanced = TRUE,
label.columns = FALSE)
PCHeatmap(object = pbmc,
pc.use = 1:12,
cells.use = 50,
do.balanced = TRUE,
label.columns = FALSE,
use.full = FALSE)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 0.6,
print.output = 0,
save.SNN = TRUE)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
# find all markers of cluster 1
cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 1, min.pct = 0.25)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 0.6,
print.output = 0,
save.SNN = TRUE)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 1,
print.output = 0,
save.SNN = TRUE)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 1,
print.output = 0)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
# find all markers of cluster 1
cluster1.markers <- FindMarkers(object = pbmc, ident.1 = 1, min.pct = 0.25)
print(x = head(x = cluster1.markers, n = 5))
# find all markers distinguishing cluster 5 from clusters 0 and 3
cluster5.markers <- FindMarkers(object = pbmc, ident.1 = 5, ident.2 = c(0, 3),
min.pct = 0.25)
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
library(dplyr)
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
## Warning in BuildSNN(object = object, genes.use = genes.use, reduction.type
## = reduction.type, : Build parameters exactly match those of already
## computed and stored SNN. To force recalculation, set force.recalc to TRUE.
# Demonstration of how to plot two tSNE plots side by side, and how to color
# points based on different criteria
plot1 <- TSNEPlot(object = pbmc, do.return = TRUE, no.legend = TRUE, do.label = TRUE)
plot2 <- TSNEPlot(object = pbmc, do.return = TRUE, group.by = "ClusterNames_0.6",
no.legend = TRUE, do.label = TRUE)
# First lets stash our identities for later
pbmc <- StashIdent(object = pbmc, save.name = "ClusterNames_0.6")
# Note that if you set save.snn=T above, you don't need to recalculate the
# SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10,
resolution = 0.8, print.output = FALSE)
top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(10, avg_logFC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of
# every cell name
DoHeatmap(object = pbmc, genes.use = top10$gene, slim.col.label = TRUE, remove.key = TRUE)
?pbmc+pbmc_small
?pbmc_small
VariableGenePlot(object = pbmc,
do.text = TRUE,
cex.use = 0.5,
cex.text.use = 0.5,
do.spike = FALSE,
pch.use = 16,
col.use = "black",
spike.col.use = "red",
plot.both = FALSE,
do.contour = TRUE,
contour.lwd = 3,
contour.col = "white",
contour.lty = 2,
x.low.cutoff = 0.1,
x.high.cutoff = 8,
y.cutoff = 1,
y.high.cutoff = Inf)
set.seed(2019)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
# save.SNN = T saves the SNN so that the clustering algorithm can be rerun
# using the same graph but with a different resolution value (see docs for
# full details)
set.seed(2019)
pbmc <- FindClusters(object = pbmc,
reduction.type = "pca",
dims.use = 1:10,
resolution = 1,
print.output = 0)
set.seed(2019)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
library(CountClust)
library(Seurat)
# deng.counts <- exprs(Deng2014MouseESC)
# deng.meta_data <- pData(Deng2014MouseESC)
# deng.gene_names <- rownames(deng.counts)
pbmc_counts <- as.matrix(pbmc_small@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- pbmc_FitGoM$fit$omega
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
## Add Topic Scores to Meta Data Part of the Seurat Object
pbmc_small@meta.data <- cbind(pbmc_meta, omega)
# deng.counts <- exprs(Deng2014MouseESC)
# deng.meta_data <- pData(Deng2014MouseESC)
# deng.gene_names <- rownames(deng.counts)
pbmc_counts <- as.matrix(pbmc_small@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- pbmc_FitGoM$fit$omega
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
## Add Topic Scores to Meta Data Part of the Seurat Object
pbmc_small@meta.data <- cbind(pbmc_meta, omega)
## ggplot object, you can add layers
p1 <- TSNEPlot(pbmc_small, do.return = TRUE) + labs(title = "Resolution 1") ## return ggplot object
p1
p2 <- FeaturePlot(object = pbmc_small,
features.plot = c("topic1", "topic2", "topic3", "topic4"),
cols.use = c("grey", "blue"),
reduction.use = "tsne", do.return = TRUE) ## return ggplot object
p2
plot_grid(p1, p2)
class(p2)
plot_grid(p1, p2[[1]], p2[[2]], p2[[3]], p2[[4]])
?RunICA
pbmc <- RunICA(object = pbmc,
pc.genes = pbmc@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
pbmc <- RunICA(object = pbmc,
ic.genes = pbmc@var.genes,
do.print = TRUE,
pcs.print = 1:5,
genes.print = 5)
pbmc <- RunICA(object = pbmc,
ic.genes = pbmc@var.genes,
do.print = TRUE,
ics.print = 1:5,
genes.print = 5)
pbmc <- RunICA(object = pbmc,
ic.genes = pbmc@var.genes,
ics.print = 1:5,
genes.print = 5)
pbmc_small <- RunICA(pbmc_small, ics.compute=5)
?RunPCA
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2)
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2)
pbmc@ident
pbmc@ident <- NULL
pbmc@ident <- ''
pbmc@ident <- factor()
pbmc@meta.data
pbmc@meta.data <- data.frame()
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
pbmc@meta.data <- data.frame()
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
pbmc@meta.data <- data.frame()
library(CountClust)
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
pbmc <- pbmc_small
pbmc@meta.data
pbmc@meta.data[,1:2]
View(pbmc_small@meta.data)
pbmc <- pbmc_small
pbmc@ident <- factor()
SetIdent(pbmc_small, "res.1")
SetIdent(pbmc_small, res.1)
?SetIdent
SetIdent(pbmc_small, cells.use = res.1, ident.use = 'res.1')
SetIdent(pbmc_small, ident.use = 'res.1')
pbmc_small@ident
# Find discriminating markers
tcell.markers <- FindMarkers(object = pbmc, ident.1 = 0, ident.2 = 1)
## Set Cluster Identity to the clustering using a resolution of 1 (res.1)
SetIdent(pbmc_small, ident.use = 'res.1')
pbmc_counts <- as.matrix(pbmc_small@data)
pbmc_meta <- pbmc_small@meta.data
gene_names <- rownames(pbmc_counts)
pbmc_FitGoM <- FitGoM(t(pbmc_counts), K=4)
omega <- pbmc_FitGoM$fit$omega
annotation <- data.frame(sample_id = rownames(omega),
tissue_label = paste0("topic", 1:4))
colnames(omega) <- paste0("topic", 1:4)
rownames(omega) <- annotation$sample_id;
StructureGGplot(omega = omega,
annotation = annotation,
palette = RColorBrewer::brewer.pal(4, "Dark2"),
yaxis_label = "Cells",
order_sample = TRUE,
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 7,
axis_label_face = "bold"))
## Add Topic Scores to Meta Data Part of the Seurat Object
pbmc_small@meta.data <- cbind(pbmc_meta, omega)
set.seed(2019)
pbmc <-RunTSNE(pbmc, reduction.use = "pca", dims.use = 1:5, perplexity=10)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc)
rm(list=ls())
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
library(CountClust)
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
library(Seurat)
library(dplyr)
library(ggplot2)
pbmc <- pbmc_small
pbmc@ident <- factor()
# The number of genes and UMIs (nGene and nUMI) are automatically calculated
# for every object by Seurat.  For non-UMI data, nUMI represents the sum of
# the non-normalized values within a cell We calculate the percentage of
# mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and
# non-log-normalized counts The % of UMI mapping to MT-genes is a common
# scRNA-seq QC metric.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
